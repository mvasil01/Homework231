<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Autocomplete Web UI</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1d3557, #457b9d);
      color: #1d3557;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .app-container {
      background: #f1faee;
      margin-top: 40px;
      padding: 30px 28px;
      border-radius: 16px;
      box-shadow: 0 18px 35px rgba(0, 0, 0, 0.25);
      width: 100%;
      max-width: 680px;
    }

    h1 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 28px;
      text-align: center;
      color: #1d3557;
    }

    .subtitle {
      text-align: center;
      font-size: 14px;
      color: #457b9d;
      margin-bottom: 20px;
    }

    .section {
      margin-bottom: 24px;
      padding-bottom: 18px;
      border-bottom: 1px solid #e0e5ec;
    }

    .section:last-of-type {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .field-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    label {
      font-size: 14px;
      color: #1d3557;
    }

    input[type="text"], input[type="number"] {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #a8dadc;
      flex: 1;
      min-width: 0;
      background: #fff;
      font-size: 14px;
    }

    input[type="text"]:focus,
    input[type="number"]:focus {
      outline: none;
      border-color: #457b9d;
      box-shadow: 0 0 0 2px rgba(69, 123, 157, 0.25);
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 13px;
      cursor: pointer;
      background: #457b9d;
      color: #f1faee;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.15s ease;
    }

    button:hover {
      background: #1d3557;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.18);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    button.secondary {
      background: #a8dadc;
      color: #1d3557;
    }

    button.secondary:hover {
      background: #89c2d9;
    }

    h2 {
      font-size: 18px;
      margin-bottom: 6px;
      margin-top: 18px;
      color: #1d3557;
    }

    #output {
      background: #fff;
      border-radius: 10px;
      padding: 12px 14px;
      min-height: 80px;
      border: 1px solid #dee2e6;
      white-space: pre-wrap;
      font-size: 13px;
      color: #222;
      overflow-x: auto;
    }

    .hint {
      font-size: 12px;
      color: #6c757d;
      margin-top: 4px;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      background: #e9f5ff;
      color: #1d3557;
      margin-left: 6px;
    }

    /* Wrappers for dropdown positioning */
    .prefix-wrapper {
      position: relative;
      width: 100%;
    }

    /* Live suggestions dropdown */

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #ced4da;
      margin-top: 4px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      max-height: 240px;
      overflow-y: auto;
      z-index: 100;
      font-size: 13px;
    }

    .suggestions.hidden {
      display: none;
    }

    .suggestion-item {
      padding: 8px 10px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .suggestion-item span.freq {
      font-size: 11px;
      color: #6c757d;
    }

    .suggestion-item:hover {
      background: #f1f3f5;
    }

    /* Highlighted parts in suggestions */
    .suggestion-item span.prefix-part {
      font-weight: 600;
      color: #1d3557;
    }
    .suggestion-item span.suffix-part {
      color: #495057;
    }

    /* Selected (keyboard-focused) suggestion */
    .suggestion-item.selected {
      background: #e7f1ff;
    }

    /* Next-letter banner */
    .next-letter-banner {
      padding: 6px 10px;
      border-bottom: 1px solid #e0e5ec;
      font-size: 12px;
      color: #495057;
      background: #f8f9fa;
    }
    .next-letter-banner span.letter {
      font-weight: 700;
      color: #1d3557;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1>Autocomplete</h1>
    <div class="subtitle">
      Compressed trie · Robin Hood hashing · frequency-based suggestions
    </div>

    <!-- Prefix-based actions -->
    <div class="section">
      <label for="prefix">
        Prefix
        <span class="pill">Live suggestions enabled</span>
      </label>

      <!-- wrapper so dropdown can sit under input -->
      <div class="prefix-wrapper">
        <div class="field-row" style="margin-bottom: 4px;">
          <input id="prefix" type="text" placeholder="Start typing (e.g. ap, ban, car)...">
          <input id="k" type="number" min="1" value="5" style="max-width:90px;" title="k">
        </div>

        <!-- live suggestions dropdown for prefix -->
        <div id="suggestions" class="suggestions hidden"></div>
      </div>

      <div class="btn-row">
        <button onclick="doTopK()">Top-K suggestions</button>
        <button class="secondary" onclick="doAvg()">Average frequency</button>
        <button class="secondary" onclick="doNext()">Predict next letter</button>
      </div>

      <div class="hint">
        As you type in the prefix field, the dropdown shows the top-K suggestions and the predicted next letter.  
        Buttons still work and use the same backend endpoints.
      </div>
    </div>

    <!-- Exact search -->
    <div class="section">
      <label for="word">
        Exact word search (with suggestions)
      </label>
      <div class="prefix-wrapper">
        <div class="field-row">
          <input id="word" type="text" placeholder="Enter full word (e.g. apple, banana)...">
        </div>
        <!-- live suggestions dropdown for word search -->
        <div id="suggestions-word" class="suggestions hidden"></div>
      </div>
      <div class="btn-row">
        <button onclick="doSearch()">Search word</button>
      </div>
      <div class="hint">
        As you type in the word field, you’ll also see suggestions below it (using the same top-K logic).
      </div>
    </div>

    <!-- Output -->
    <div>
      <h2>Result</h2>
      <pre id="output">Start typing a prefix above to see live suggestions.</pre>
    </div>
  </div>

  <script>
    const API_BASE = "http://localhost:8000";

    const prefixInput = document.getElementById("prefix");
    const suggestionsBox = document.getElementById("suggestions");
    const wordInput = document.getElementById("word");
    const suggestionsBoxWord = document.getElementById("suggestions-word");
    const output = document.getElementById("output");

    // State for prefix dropdown
    let liveTimeout = null;          // debounce timer for prefix
    let suggestionsData = [];        // current array of {word, importance}
    let suggestionsPrefix = "";      // current prefix for dropdown
    let suggestionsNextLetter = "";  // current predicted next letter
    let selectedIndex = -1;          // keyboard-selected index (prefix)

    // State for word dropdown
    let liveTimeoutWord = null;      // debounce timer for word input
    let suggestionsDataWord = [];    // array of {word, importance}
    let suggestionsPrefixWord = "";  // current prefix in word field
    let selectedIndexWord = -1;      // keyboard-selected index (word)

    function getK() {
      const kInput = document.getElementById("k");
      let k = parseInt(kInput.value, 10);
      if (isNaN(k) || k <= 0) k = 5;
      return k;
    }

    function hideSuggestions() {
      suggestionsBox.classList.add("hidden");
      suggestionsBox.innerHTML = "";
      suggestionsData = [];
      suggestionsPrefix = "";
      suggestionsNextLetter = "";
      selectedIndex = -1;
    }

    function hideSuggestionsWord() {
      suggestionsBoxWord.classList.add("hidden");
      suggestionsBoxWord.innerHTML = "";
      suggestionsDataWord = [];
      suggestionsPrefixWord = "";
      selectedIndexWord = -1;
    }

    function renderSuggestions() {
      if (!suggestionsData || suggestionsData.length === 0) {
        hideSuggestions();
        return;
      }

      const prefix = suggestionsPrefix;
      const nextLetter = suggestionsNextLetter;

      let html = "";

      // Banner for predicted next letter
      if (nextLetter && nextLetter.length > 0) {
        html += `
          <div class="next-letter-banner">
            Predicted next letter after "<strong>${prefix}</strong>":
            <span class="letter">'${nextLetter}'</span>
          </div>
        `;
      }

      const lowerPrefix = prefix.toLowerCase();

      suggestionsData.forEach((wf, i) => {
        const word = wf.word;
        const lowerWord = word.toLowerCase();

        let wordHtml;
        if (lowerWord.startsWith(lowerPrefix)) {
          const pre = word.substring(0, prefix.length);
          const suf = word.substring(prefix.length);
          wordHtml = `
            <span class="prefix-part">${pre}</span><span class="suffix-part">${suf}</span>
          `;
        } else {
          // fallback
          wordHtml = `<span class="word">${word}</span>`;
        }

        const selectedClass = (i === selectedIndex) ? " selected" : "";

        html += `
          <div class="suggestion-item${selectedClass}" data-index="${i}">
            <div>${wordHtml}</div>
            <span class="freq">freq = ${wf.importance}</span>
          </div>
        `;
      });

      suggestionsBox.innerHTML = html;
      suggestionsBox.classList.remove("hidden");

      // Click handler for items (prefix)
      Array.from(suggestionsBox.querySelectorAll(".suggestion-item")).forEach(item => {
        item.addEventListener("click", () => {
          const idx = parseInt(item.getAttribute("data-index"), 10);
          if (!isNaN(idx) && suggestionsData[idx]) {
            const word = suggestionsData[idx].word;
            prefixInput.value = word;
            hideSuggestions();
            output.textContent = `Selected suggestion from prefix box: "${word}"`;
          }
        });
      });
    }

    function renderSuggestionsWord() {
      if (!suggestionsDataWord || suggestionsDataWord.length === 0) {
        hideSuggestionsWord();
        return;
      }

      const prefix = suggestionsPrefixWord;
      const lowerPrefix = prefix.toLowerCase();

      let html = "";

      suggestionsDataWord.forEach((wf, i) => {
        const word = wf.word;
        const lowerWord = word.toLowerCase();

        let wordHtml;
        if (lowerWord.startsWith(lowerPrefix)) {
          const pre = word.substring(0, prefix.length);
          const suf = word.substring(prefix.length);
          wordHtml = `
            <span class="prefix-part">${pre}</span><span class="suffix-part">${suf}</span>
          `;
        } else {
          wordHtml = `<span class="word">${word}</span>`;
        }

        const selectedClass = (i === selectedIndexWord) ? " selected" : "";

        html += `
          <div class="suggestion-item${selectedClass}" data-index="${i}">
            <div>${wordHtml}</div>
            <span class="freq">freq = ${wf.importance}</span>
          </div>
        `;
      });

      suggestionsBoxWord.innerHTML = html;
      suggestionsBoxWord.classList.remove("hidden");

      // Click handler for word suggestions
      Array.from(suggestionsBoxWord.querySelectorAll(".suggestion-item")).forEach(item => {
        item.addEventListener("click", () => {
          const idx = parseInt(item.getAttribute("data-index"), 10);
          if (!isNaN(idx) && suggestionsDataWord[idx]) {
            const word = suggestionsDataWord[idx].word;
            wordInput.value = word;
            hideSuggestionsWord();
            output.textContent = `Selected word suggestion: "${word}"`;
          }
        });
      });
    }

    function showSuggestions(data, prefix, nextLetter) {
      suggestionsData = data || [];
      suggestionsPrefix = prefix || "";
      suggestionsNextLetter = nextLetter || "";
      selectedIndex = -1; // reset selection
      renderSuggestions();
    }

    function showSuggestionsWord(data, prefix) {
      suggestionsDataWord = data || [];
      suggestionsPrefixWord = prefix || "";
      selectedIndexWord = -1;
      renderSuggestionsWord();
    }

    async function fetchSuggestions(prefix) {
      const k = getK();
      try {
        const [resTopK, resNext] = await Promise.all([
          fetch(`${API_BASE}/topk?prefix=${encodeURIComponent(prefix)}&k=${k}`),
          fetch(`${API_BASE}/next?prefix=${encodeURIComponent(prefix)}`)
        ]);

        const data = await resTopK.json();
        const nextLetterText = await resNext.text();
        const nextLetter = nextLetterText && nextLetterText !== "\0" ? nextLetterText : "";

        if (prefixInput.value.trim() !== prefix) return; // user changed

        showSuggestions(data, prefix, nextLetter);
      } catch (e) {
        console.error("Error fetching suggestions:", e);
        hideSuggestions();
      }
    }

    async function fetchSuggestionsWord(prefix) {
      const k = getK();
      try {
        const res = await fetch(`${API_BASE}/topk?prefix=${encodeURIComponent(prefix)}&k=${k}`);
        const data = await res.json();

        if (wordInput.value.trim() !== prefix) return;

        showSuggestionsWord(data, prefix);
      } catch (e) {
        console.error("Error fetching word suggestions:", e);
        hideSuggestionsWord();
      }
    }

    // Live update handler with debounce for prefix
    prefixInput.addEventListener("input", () => {
      const prefix = prefixInput.value.trim();

      if (!prefix) {
        hideSuggestions();
        output.textContent = "Start typing a prefix above to see live suggestions.";
        return;
      }

      if (liveTimeout) clearTimeout(liveTimeout);
      liveTimeout = setTimeout(() => {
        fetchSuggestions(prefix);
      }, 200);
    });

    // Live update handler with debounce for word input
    wordInput.addEventListener("input", () => {
      const prefix = wordInput.value.trim();

      if (!prefix) {
        hideSuggestionsWord();
        return;
      }

      if (liveTimeoutWord) clearTimeout(liveTimeoutWord);
      liveTimeoutWord = setTimeout(() => {
        fetchSuggestionsWord(prefix);
      }, 200);
    });

    // Keyboard navigation: ↑, ↓, Enter, Esc for prefix input
    prefixInput.addEventListener("keydown", (e) => {
      if (suggestionsBox.classList.contains("hidden") || suggestionsData.length === 0) {
        return;
      }

      if (e.key === "ArrowDown") {
        e.preventDefault();
        if (selectedIndex < suggestionsData.length - 1) {
          selectedIndex++;
        } else {
          selectedIndex = 0;
        }
        renderSuggestions();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        if (selectedIndex > 0) {
          selectedIndex--;
        } else {
          selectedIndex = suggestionsData.length - 1;
        }
        renderSuggestions();
      } else if (e.key === "Enter") {
        if (selectedIndex >= 0 && selectedIndex < suggestionsData.length) {
          e.preventDefault();
          const word = suggestionsData[selectedIndex].word;
          prefixInput.value = word;
          hideSuggestions();
          output.textContent = `Selected suggestion from prefix box: "${word}"`;
        }
      } else if (e.key === "Escape") {
        e.preventDefault();
        hideSuggestions();
      }
    });

    // Keyboard navigation: ↑, ↓, Enter, Esc for word input
    wordInput.addEventListener("keydown", (e) => {
      if (suggestionsBoxWord.classList.contains("hidden") || suggestionsDataWord.length === 0) {
        return;
      }

      if (e.key === "ArrowDown") {
        e.preventDefault();
        if (selectedIndexWord < suggestionsDataWord.length - 1) {
          selectedIndexWord++;
        } else {
          selectedIndexWord = 0;
        }
        renderSuggestionsWord();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        if (selectedIndexWord > 0) {
          selectedIndexWord--;
        } else {
          selectedIndexWord = suggestionsDataWord.length - 1;
        }
        renderSuggestionsWord();
      } else if (e.key === "Enter") {
        if (selectedIndexWord >= 0 && selectedIndexWord < suggestionsDataWord.length) {
          e.preventDefault();
          const word = suggestionsDataWord[selectedIndexWord].word;
          wordInput.value = word;
          hideSuggestionsWord();
          output.textContent = `Selected word suggestion: "${word}"`;
        }
      } else if (e.key === "Escape") {
        e.preventDefault();
        hideSuggestionsWord();
      }
    });

    // Close dropdowns when clicking outside
    document.addEventListener("click", (e) => {
      const isClickInsidePrefix = prefixInput.contains(e.target);
      const isClickInsidePrefixDropdown = suggestionsBox.contains(e.target);
      const isClickInsideWord = wordInput.contains(e.target);
      const isClickInsideWordDropdown = suggestionsBoxWord.contains(e.target);

      if (!isClickInsidePrefix && !isClickInsidePrefixDropdown) {
        hideSuggestions();
      }
      if (!isClickInsideWord && !isClickInsideWordDropdown) {
        hideSuggestionsWord();
      }
    });

    // === Button-based actions (TopK, Avg, Next, Search) ===

    async function doTopK() {
      const prefix = prefixInput.value.trim();
      const k = getK();

      if (!prefix) {
        output.textContent = "Please enter a prefix first.";
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/topk?prefix=${encodeURIComponent(prefix)}&k=${k}`);
        const data = await res.json();
        if (data.length === 0) {
          output.textContent = `No suggestions for "${prefix}".`;
          return;
        }
        output.textContent =
          `Top ${data.length} suggestions for "${prefix}":\n\n` +
          data.map((wf, i) =>
            `${i + 1}. ${wf.word}  (freq = ${wf.importance})`
          ).join("\n");
      } catch (e) {
        output.textContent = "Error calling /topk: " + e;
      }
    }

    async function doAvg() {
      const prefix = prefixInput.value.trim();

      if (!prefix) {
        output.textContent = "Please enter a prefix first.";
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/avg?prefix=${encodeURIComponent(prefix)}`);
        const text = await res.text();
        const value = parseFloat(text);
        if (isNaN(value)) {
          output.textContent = `Average frequency for "${prefix}": (invalid response: ${text})`;
        } else {
          output.textContent = `Average frequency for words starting with "${prefix}": ${value.toFixed(2)}`;
        }
      } catch (e) {
        output.textContent = "Error calling /avg: " + e;
      }
    }

    async function doNext() {
      const prefix = prefixInput.value.trim();

      if (!prefix) {
        output.textContent = "Please enter a prefix first.";
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/next?prefix=${encodeURIComponent(prefix)}`);
        const text = await res.text();
        if (!text) {
          output.textContent = `No next-letter suggestion for "${prefix}".`;
        } else {
          output.textContent = `Suggested next letter after "${prefix}": '${text}'`;
        }
      } catch (e) {
        output.textContent = "Error calling /next: " + e;
      }
    }

    async function doSearch() {
      const word = wordInput.value.trim();

      if (!word) {
        output.textContent = "Please enter a word to search.";
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/search?word=${encodeURIComponent(word)}`);
        const text = await res.text();
        const found = (text.trim() === "true");
        output.textContent = `Word "${word}" found? ${found ? "✅ Yes" : "❌ No"}`;
      } catch (e) {
        output.textContent = "Error calling /search: " + e;
      }
    }
  </script>
</body>
</html>
